\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{UARTIntHandler}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{ui32Status}\PYG{p}{;}
    \PYG{c+c1}{// Get the interrupt status.}
    \PYG{n}{ui32Status} \PYG{o}{=} \PYG{n}{UARTIntStatus}\PYG{p}{(}\PYG{n}{UART0\PYGZus{}BASE}\PYG{p}{,} \PYG{n+nb}{true}\PYG{p}{);}
    \PYG{c+c1}{//}
    \PYG{c+c1}{// Clear the asserted interrupts.}
    \PYG{c+c1}{//}
    \PYG{n}{UARTIntClear}\PYG{p}{(}\PYG{n}{UART0\PYGZus{}BASE}\PYG{p}{,} \PYG{n}{ui32Status}\PYG{p}{);}

    \PYG{c+c1}{//UARTSend((uint8\PYGZus{}t *)\PYGZdq{}nah\PYGZbs{}r\PYGZbs{}n\PYGZdq{}, 5);}
    \PYG{c+c1}{//}
    \PYG{c+c1}{// Loop while there are characters in the receive FIFO.}

    \PYG{k}{while}\PYG{p}{(}\PYG{n}{UARTCharsAvail}\PYG{p}{(}\PYG{n}{UART0\PYGZus{}BASE}\PYG{p}{))}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Read the next character from the UART and write it back to the UART.}
        \PYG{n}{UARTCharPutNonBlocking}\PYG{p}{(}\PYG{n}{UART0\PYGZus{}BASE}\PYG{p}{,} \PYG{n}{UARTCharGetNonBlocking}\PYG{p}{(}\PYG{n}{UART0\PYGZus{}BASE}\PYG{p}{));}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{send\PYGZus{}u32}\PYG{p}{(}\PYG{n}{theta\PYGZus{}target} \PYG{o}{\PYGZhy{}} \PYG{n}{theta}\PYG{p}{);}
    \PYG{n}{send\PYGZus{}u32}\PYG{p}{(}\PYG{n}{pos}\PYG{p}{);}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}
